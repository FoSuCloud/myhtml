## promise对象三种状态
1. 异步操作未完成(pending)
2. 异步操作已完成(resolved)
3. 异步操作失败(rejected)
* promise对象的状态变化情况只有两种，`从pending到resolved`,`从pending到rejected`

## 微任务
1. 例子:
```
	// 虽然setTimeout在前面,但是这是异步任务
	setTimeout(function(){
		console.log(3)
	},0)
	
	// 虽然promise也是异步任务,但是promise是微任务,在本轮循环中执行,而setTimeout是宏任务,在下一轮任务中执行
	new Promise(function(resolve,reject){
		resolve(2)
		// resolve执行成功后会把参数传递给then,然后就可以打印了
	}).then(console.log)

	// 这是同步任务,解析到这里就执行,所以首先执行这个
	console.log(1)
```
2. `对于js来说，有同步操作和异步操作，解析script标签内容的时候，先执行同步操作，再执行异步操作，但是任务又分为宏任务和微任务`
3. 异步任务(操作)指的是不进入主线程，而进入任务队列(task queue)的任务，只有任务队列通知主线程，某个异步任务可以执行了，异步任务才会进入主线程
4. `所有的同步任务都在主线程中执行，形成了执行栈`，除了主线程还有一个任务队列，只要异步任务有了结果，就在任务队列中放置一个事件
5. `所谓回调函数就是被主线程挂起来的代码，当主线程开始执行异步任务的时候，其实就是执行回调函数，所以必须指定回调函数`
6. 主线程从任务队列中读取异步任务的过程是循环不断的，所以也被称为`事件循环(event loop)`
7. `除了异步任务，任务队列还可以放置定时器事件(setTimeout,setInterval),定时器事件不属于异步任务，但是都是被放在任务队列中的`
8. 但是我们说了存在`宏任务与微任务`
* 宏任务一般是:整体代码script,setTimeout,setInterval
* 微任务:promise，process.nextTick
* `在我们首次执行完整体代码script的时候相当于第一次执行宏任务，执行完宏任务之后会先去执行微任务，然后再去执行下一轮宏任务(在例子中，setTimeout就是下一轮要被执行的宏任务，而promise属于本轮结束后立刻被执行的微任务，所以先执行promise的then函数再执行定时器任务)`

## hasOwnProperty
* obj.hasOwnProperty('val')方法是判断该对象obj中是否有val属性或者方法(`不能检测原型链中是否有该属性或者方法`)
* obj1.isPrototypeOf(obj2)方法是判断`obj2对象的实例是否在obj1对象的原型链中`

## Math
1. Math.round(11.5)==>12,Math.round(-11.5)==> -11
2. Math.max(..args),可以接受多个参数(`不支持直接传递一个数组，但是apply回调函数会把数组处理为一连串参数，所以可以使用apply传递数组`)，返回最大值，使用回调函数可以是`Math.max.call(1,3,2,5);Math.max.apply([5,3,2,7])`
```
	console.log(Math.max(2,3,542,55,4))
	console.log(Math.max.call(null,35,656,23,76))
	console.log(Math.max.apply(null,[5,3,12,7,23]))
```
3. -Math.ceil函数的用法Math.ceil(x) -- 返回`大于等于数字参数的最小整数`(取整函数)，对数字进行上舍入
```
	console.log(Math.ceil(6.5));//7
	console.log(Math.ceil(6.3));//7
	console.log(Math.ceil(6.7));//7
	console.log(Math.ceil(-6.7));//-6
	console.log(Math.ceil(-6.1));//-6
```
## of,in,forEach
```
	// 1. in方法可以遍历对象和数组,遍历对象的键,遍历数组的下标
	var obj={
		name:11,
		age:77,
		sex:'男'
	}
	var arr=[4,2,6,2]
	// 1.1 遍历对象的键
	for(i in obj){
		console.log(i);//打印属性(键)
	}
	// 1.2 使用in来遍历数组,遍历的是下标
	for(k in arr){
		console.log(k)
	}

	// 使用of方法来遍历数组的值,注意不能遍历对象
	// 2.1打印值,不能使用of打印对象的值,但是of可以遍历数组的值
	for(j of arr){
		console.log(j)
	}


	// forEach可以遍历数组,不可以遍历对象
	// 3.1错误,forEach不能遍历对象,只能遍历数组
	// arr.forEach( item => console.log(item))

	// 3.2 除非使用Object.keys().forEach()就可以遍历对象了
	Object.keys(obj).forEach(item => {
		console.log('1'+item)
	})
```

## 鼠标移入移出
1. `ie浏览器`:有onmouseenter,onmouseleace属性，表示鼠标移入和鼠标移出，`不会冒泡`
2. `其他浏览器`:有onmouseover,onmouseout属性，表示鼠标移入和鼠标移出，`会冒泡`

## js的继承
* 有六种:`原型链继承，构造函数继承，组合继承，原型式继承，组合式继承，寄生组合式继承`
* [参考](https://www.cnblogs.com/Leophen/p/11401734.html)

## 鼠标移入移出
1. `ie浏览器`:有onmouseenter,onmouseleace属性，表示鼠标移入和鼠标移出，`不会冒泡`
2. `其他浏览器`:有onmouseover,onmouseout属性，表示鼠标移入和鼠标移出，`会冒泡`

## DOM树中的节点类型
1. element元素节点: 所有的元素节点(html标签)都是element nodes
2. text node文本节点:在html中的文本内容都是text nodes
3. comment注释节点:comments属于注释节点
4. document节点:可以说`是一种节点格式，但是节点数的根节点也是document`

## 创建对象(还不懂)
1. Object.create(obj,propertiesObject)：`obj是新创建的对象的原型`，`propertiesObject是新创建的对象的名称或者属性`
* Object.create的实现方式
```
Object.create=function(o){
	var F=function(){};
	F.prototype=o;
	return new F()
}
Object.create是内部定义一个对象，并且让F.prototype对象 赋值为引进的对象/函数 o，并return出一个新的对象
```
2. new func();实际上就是
```
var o=new Object();
o.__proto__=Base.prototype
Base.call(o)
```
* [参考](https://blog.csdn.net/blueblueskyhua/article/details/73135938)

## isNaN,parseInt函数
```
	// 1. isNaN()函数用来判断一个数是否是NaN;
	// 只有一个值是NaN或者能被转换为NaN的时候才返回true 
	console.log(isNaN('e'));//true,因为e可以被转换为NaN 
	console.log(isNaN('11'));//false,因为字符串可以被转换为数字,不能被转为NaN 
	console.log(isNaN(null));//false,因为null可以被转换为0,不能被转为NaN 
	console.log(isNaN(NaN));// true,NaN返回true
	
	// 2. parseInt(string,raix)函数有两个参数
	// 2.1 注意:string字符串只会被解析从第一个字符开始直到不是数字的字符部分
	console.log(parseInt('223'));//223
	// 2.2 当字符串中间存在非数字,那么就只解析前面是数字的部分字符
	console.log(parseInt('22e3'));//22
	// 2.3 如果字符串中第一个字符就不是数字,那么返回NaN 
	console.log(parseInt('e21'));//NaN
	
	// 对于parseInt()函数还有一个易考点,就是利用数组的下标,还记得parseInt()函数的第二个参数吗？
	// 2.4 parseInt()函数的第二个参数指的就是进制,这个参数小于2或者大于36的时候,都会返回NaN 
	console.log(parseInt(1,1));//NaN ,因为第二个参数是1表示1进制<2,所以错误
	console.log(parseInt(1,2));//1,因为表示二进制 =2,在范围内
	// 2.5 我们一般都是省略这个参数的,这个时候就是默认为10进制
	console.log(parseInt(99));//99
	// 2.6 我们第二个参数使用0的时候也是使用十进制
	console.log(parseInt(99,0));//99
	// 2.7 如果第一个参数前缀使用0x/0X则表示使用16进制
	console.log(parseInt(0x99));//153=16*9+9
	console.log(parseInt(0x99,10));//如果第一个参数使用了0x表示十六进制,那么第二个参数设置了值也无效
	
	// 2.8 看一个实例,对于数组
	var arr=[1,2,3,2,5];
	console.log(arr.map(parseInt));//[1, NaN, NaN, 2, NaN]
	// arr.map方法就是对于数组arr里面的每一项都去使用方法里面的函数,最后返回新数组
	// 因为map方法会有索引,所以实际上就是 
	parseInt(1,0);//1,因为0表示十进制
	parseInt(2,1);//1进制<2，所以错啦!
	parseInt(3,2);// 2进制,但是3不在0——2范围内(3应该改为11),所以不符合2进制要求
	parseInt(2,3);//符合,因为三进制是0-3,而2在范围内
	parseInt(5,4);//4进制不包括5,所以NaN
```

## 暂时性死区(temporal dead zone)
* js引擎在扫描代码的时候，如果发现`var 声明就把声明放到所在作用域的顶部`，`如果是let/const声明 就把声明语句放到暂时性死区，只有等到执行变量声明之后变量才会从tdz中移出，移出之后才能被正常访问`
* 如果`提前使用了暂时性死区中的变量，那么就会报错referenerror`


## 模板字面量``
1. 多行字符串不需要用 + 加号隔开了，直接换行就可以
2. 变量嵌入字符串中也不需要用加号了，直接用 ${}
3. 可以在反字符串中进行简单的逻辑运算

## 默认参数也存在暂时性死区
```
	<!-- 1. -->
	function one(a=b,b=5){
		console.log(a,b)
	}
	// one();//ReferenceError: Cannot access 'b' before initialization
	// 2.相等于
	// let a=b;
	// let b=5;
	// console.log(a,b);//ReferenceError: Cannot access 'b' before initialization
	
	<!-- 3.使用var声明提前 -->
	var c=d;
	var d=5;
	console.log(c,d);//undefined 5 因为var存在声明提前
	
	<!-- 4.改变顺序就不会出错 -->
	function two(a=5,b=a){
		console.log(a,b)
	}
	// two();//5 5
```

## 默认参数值
* es6中新增了默认参数值，例如time(a,b=3,callback){},当我们使用time(1,2,3)时，b=2。当我们使用`time(1,2)时，a=1,b=2,callback=undefined`。
* 注意！当我们使用undefined，`time(1,undefined,function(){})的时候，b不变`，因为`使用undefined相当于没有赋值`，所以b还是使用默认值。
* 当我们使用null,time(1,null,function(){})的时候，b不使用默认值，因为此时`b使用传递过来的合法值null `
