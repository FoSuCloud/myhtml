## 1.选择器权重
* 内联 权重1000 ;ID 选择器 权重：100; 类 伪类 属性选择器 权重：10 ; 元素选择器 权重：1 
* 除!important 外，内联权重最大！

## 2.line-height,font-size,vertical-align
* 1. 对于对齐来说，一个div内包裹着一个图片与单行短文本，图片默认对准着文本的基线(基线之下有一丢丢像素)，所以实际上是没有对齐的
* 解决方法: 图片:vertical-align:bottom,设置图片对齐文本的底部
* 这样子勉强还可以，但是文本默认有一定的line-height(文本内容区+文本框内高度),所以要直接对准文字需要对文本使用line-height:0
* 2. 对于间距上来说，一个div内包裹着一个图片与单行短文本，图片与文本的左右间距是存在的，当我们需要精确的屏幕像素时是不允许的
* 解决方法: 对父元素div,font-size:0;使得内联非置换元素的直接消失，所以我们需要给文本元素添加font-size:12px这样，然后我们再看水平方向，图片与文本之间的左右间距就消失了
* [参考链接](https://blog.csdn.net/u010250808/article/details/78347814)
`这方面的知识还比较薄弱~`

## 3.display与visibility
* 使用display:none是把元素从视觉角度消失掉，而且元素出现时候占据的位置不会依旧占据，而visibility:none虽然也是会隐藏，但是依旧占据之前的位置
* visibility依旧在文档流中占据位置，可以视为透明度为0，浏览器也会解析这个元素;而使用display:none的话，浏览器不会解析这个元素；
* 而我们使用display:none有一个坏处就是会消耗资源，因为切换display:none会导致浏览器重排，重新绘制及重新排布位置；而visibility:none仅仅是触发重绘，因为位置及元素大小没有改变

## 4.BFC
* BFC（block formatting context）块级格式化上下文,明确一点:块级格式化上下文依旧在普通文档流中，区别就在于BFC中的元素布局不会影响到外部，而且外部也不会影响到里面的元素布局；
* 创建BFC块级格式化上下文有几种方式: 1. float的值不是none; 2. position的值不是relative,static；3. display的值是inline-block、table-cell、flex、table-caption或者inline-flex； 4.`最常用的是overflow:hidden，这也是创建一个块级格式化上下文`
* 1. 引用场景`margin外边距折叠`:当我们创建一个结构为 : div-{ p p} 其中p元素有margin：10px的时候，我们两个p元素的边距不是预计的20px而是10px,因为发生了`margin外边距折叠`,解决这个问题可以用BFC，因为此时的两个p元素同属于一个块级元素(div是块级元素),同时p元素也是块级元素，所以就是一个块级元素中嵌套着两个块级元素,由于两个p块级元素是在div块级元素里面的,所以margin范围也在div中，而两个p元素的margin范围不在自己的范围内，所以也会发生margin外边距重叠的问题，而给p元素嵌套一个div就可以让p元素的margin处于自己的范围内，所以解决方法就是 ： div{p div{p}}，然后第一个p元素与子元素的div就会有20px的边距，因为子元素的div宽高已经包括了内在的p元素的margin范围
* 2. `父元素高度坍塌`:例子结构为 div{div,div},给子元素div设置浮动，然后给子元素div设置宽高，然后给父元素div设置一个背景色，可以发现父元素的背景不包括子元素，因为子元素浮动脱离了文档流，然后父元素没有设置高度，所以父元素没有包裹住的元素，因此父元素就产生了`高度坍塌`，如果要让父元素包裹住子元素的话，有两种方式，第一种是`给父元素一个浮动`，那么我们就会发现父元素会包裹住子元素，并且宽度不再是独占一行了，因为此时的父元素仅仅是一个宽高依靠子元素撑开的块级格式化上下文；第二种方式:`给父元素使用overflow:hidden清除浮动`，overflow:hidden本质上就是寻找子元素的高度，然后计算出父元素的高度，因为得到了父元素的高度，那么自然也就撑开了高度；在另一种场景中，如果我设置父元素的高度，然后设置overflow:hidden,那么父元素的高度只能是这么多，超出的子元素部分就会隐藏掉

