## 1.选择器权重
* 内联 权重1000 ;ID 选择器 权重：100; 类 伪类 属性选择器 权重：10 ; 元素选择器 权重：1 
* 属性选择器权重10，a[href] {color:red;}，只对有href属性的a标签应用该样式
* 通用选择器（*），子选择器（>）和相邻同胞选择器（+）并不在这四个等级中，所以他们的权值都为0
* +兄弟择器需要选择紧邻某个元素之后`一个元素`，而且两者有相同的父元素，如 .one+p{color:red}; .one和p元素的父元素为div
* ~兄弟选择器选择某个元素之后的`所有兄弟节点`。
* 除!important 外，内联权重最大！

## 2.line-height,font-size,vertical-align
* 1. 对于对齐来说，一个div内包裹着一个图片与单行短文本，图片默认对准着文本的基线(基线之下有一丢丢像素)，所以实际上是没有对齐的
* 解决方法: 图片:vertical-align:bottom,设置图片对齐文本的底部
* 这样子勉强还可以，但是文本默认有一定的line-height(文本内容区+文本框内高度),所以要直接对准文字需要对文本使用line-height:0
* 2. 对于间距上来说，一个div内包裹着一个图片与单行短文本，图片与文本的左右间距是存在的，当我们需要精确的屏幕像素时是不允许的
* 解决方法: 对父元素div,font-size:0;使得内联非置换元素的直接消失，所以我们需要给文本元素添加font-size:12px这样，然后我们再看水平方向，图片与文本之间的左右间距就消失了
* [参考链接](https://blog.csdn.net/u010250808/article/details/78347814)
`这方面的知识还比较薄弱~`

## 3.display与visibility
* 使用display:none是把元素从视觉角度消失掉，而且元素出现时候占据的位置不会依旧占据，而visibility:none虽然也是会隐藏，但是依旧占据之前的位置
* visibility依旧在文档流中占据位置，可以视为透明度为0，浏览器也会解析这个元素;而使用display:none的话，浏览器不会解析这个元素；
* 而我们使用display:none有一个坏处就是会消耗资源，因为切换display:none会导致浏览器重排，重新绘制及重新排布位置；而visibility:none仅仅是触发重绘，因为位置及元素大小没有改变

## 4.BFC
* BFC（block formatting context）块级格式化上下文,明确一点:块级格式化上下文依旧在普通文档流中，区别就在于BFC中的元素布局不会影响到外部，而且外部也不会影响到里面的元素布局；
* 创建BFC块级格式化上下文有几种方式: 1. float的值不是none; 2. position的值不是relative,static；3. display的值是inline-block、table-cell、flex、table-caption或者inline-flex； 4.`最常用的是overflow:hidden，这也是创建一个块级格式化上下文`
* 1. 引用场景`margin外边距折叠`:当我们创建一个结构为 : div-{ p p} 其中p元素有margin：10px的时候，我们两个p元素的边距不是预计的20px而是10px,因为发生了`margin外边距折叠`,解决这个问题可以用BFC，因为此时的两个p元素同属于一个块级元素(div是块级元素),同时p元素也是块级元素，所以就是一个块级元素中嵌套着两个块级元素,由于两个p块级元素是在div块级元素里面的,所以margin范围也在div中，而两个p元素的margin范围不在自己的范围内，所以也会发生margin外边距重叠的问题，而给p元素嵌套一个div就可以让p元素的margin处于自己的范围内，所以解决方法就是 ： div{p div{p}}，然后第一个p元素与子元素的div就会有20px的边距，因为子元素的div宽高已经包括了内在的p元素的margin范围
* 2. `父元素高度坍塌`:例子结构为 div{div,div},给子元素div设置浮动，然后给子元素div设置宽高，然后给父元素div设置一个背景色，可以发现父元素的背景不包括子元素，因为子元素浮动脱离了文档流，然后父元素没有设置高度，所以父元素没有包裹住的元素，因此父元素就产生了`高度坍塌`，如果要让父元素包裹住子元素的话，有两种方式，第一种是`给父元素一个浮动`，那么我们就会发现父元素会包裹住子元素，并且宽度不再是独占一行了，因为此时的父元素仅仅是一个宽高依靠子元素撑开的块级格式化上下文；第二种方式:`给父元素使用overflow:hidden清除浮动`，overflow:hidden本质上就是寻找子元素的高度，然后计算出父元素的高度，因为得到了父元素的高度，那么自然也就撑开了高度；在另一种场景中，如果我设置父元素的高度，然后设置overflow:hidden,那么父元素的高度只能是这么多，超出的子元素部分就会隐藏掉

## 5.flex-basis
* `content-width-flx-basis`,当有content,width属性的时候，flx-basis默认为width的大小；当有content,没有width属性的时候，flx-basis默认为content大小
* 当设置了width,flex-basis的时候，宽度为flx-basis的设置值；flex非常适用用于响应式网页设计，特别是使用max-width,min-width可以限制最大最小宽度，flex-grow,flex-shrink设置扩大缩小比例

## 6.utf8/gbk
* gbk编码是国内使用较多的编码，但是`只能用于简体中文`
* utf-8编码是国际上用的多的编码，可以识别简体中文，繁体中文，日文，韩文，英文，阿拉丁文等语言

## 7.link和@import的区别
1.link是xhtml标签，没有兼容性问题，而@import是css2.1才被提出的，低版本的浏览器不支持
2.link支持加载css,js，而@import只能加载css
3.link加载的内容是和页面一起加载的，而@import加载的内容要页面加载之后才被加载

## 8.css伪类选择器
* 静态伪类选择器
1. link:超链接点击之前
2. visited:链接被访问之后
* 动态伪类选择器
1. hover:鼠标放到标签上的时候
2. active:鼠标点击标签，不松手
3. focus:某个标签获得焦点的时候
---
* blur不是伪类选择器，但是在jq中blur()函数是失去焦点的意思

## 9. css中的色彩
1. rgb色彩
* 例子: color:rgb(255,0,0)指的是red:100%,green:0,blue:0,所以就出现了全红色
* rgb(0,0,0)指的就是红绿蓝都不亮，那就是黑了；如果是rgb(255,255,255)那就是全都亮了，所以就是亮瞎了，白色
2. HSL色彩
* HSL(Hue Saturation Lightness)分别指的是色相，色彩饱和度，色彩亮度
* 而Hue色相分为240度，0度的时候是红色，120度是绿色，240度是蓝色
3. HEX色彩
* HEX色彩其实也就是使用十六进制来表示色彩程度
* `一般来说，HEX色彩有六位，每两位表示一种色彩，分别是红绿黄`
* 例子:`#FF0000 => 红色； #00FF00绿色 ；#000000 黑色`
* `HEX色彩还可以用缩的形式(仅当每两位中的每一位都一样的时候可以缩写)`
* 例子: 	` #FF0000 => #F000 ; #338899 => #389`
* 但是，还存在一种情况，使用四位的HEX色彩，最后一位表示透明度
* 例子:` #FF0000 => #F00F 表示的是红色透明度为1的颜色 ；#F000 表示的是红色透明度为0的颜色(透明度为0也就看不见啦)`

## 10.input输入框内容位置颜色
1. 改变placeholder(默认内容)位置(`此处一定要使用两个冒号::`)
* `使用伪类 input::placeholder{position:relative left:20px}`
* 但是我错啦！其实直接对输入框使用padding-left就可以了，value的位置问题也解决了，之前一直弄不好
2. 改变value(值)位置
* `直接对输入框样式加上padding-left,这样placeholder内容也改变了(不需要设置relative了，变颜色就好了)，一举两得`

## 11.box-shadow/outline/border
1. box-shadow：阴影，大小`不会`影响到原来的元素大小，例子:`box-shadow:10px 10px blue`
2. outline:轮廓,大小也`不会`影响到原来的元素大小，例子:`outline:10px solid red`，而且随着focus会有相应的出现效果，随着blur会有离开效果
3. border:边框，大小会影响到原来的元素大小,例子:`border:1px solid green`


